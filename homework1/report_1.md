# 41343109

作業一

## 解題說明

本題要求用地回和非遞迴實現ackermann's函式

### 解題策略

#### 遞迴

1. 使用遞迴函式將問題拆解為更小的子問題。
2. 當 $m = 0$ 時，返回 $n + 1$ ，當 $n = 0$ 時，返回 $ack (m - 1 , n )$，當 $m !=  0$ 和 $n ! = 0$ 時，返回 $ack (m - 1 , ack(m,n-1) )$  作為遞迴的結束條件。  
3. 主程式呼叫遞迴函式，並輸出計算結果。
#### 非遞迴
1. stack 存的是外層還沒完成的 m，而 n 則在迴圈裡直接更新。
每次 m == 0 時，會把計算結果用 n 回傳，如果 stack 不空，就 pop 上層 m 繼續計算。
n == 0 時，直接改變 (m, n)，模擬 A(m-1, 1)。
## 程式實作

以下為主要程式碼：

```cpp
#include<iostream>
#include <stack>
using namespace std;
int ack(int m, int n) {
	if (m == 0)return n + 1;
	if (n == 0)return ack(m - 1, 1);
	else return ack(m - 1, ack(m, n - 1));
}
int nack(int m, int n) {
    stack<int> st;
    while (true) {
        if (m == 0) {
            n = n + 1;
            if (st.empty()) {
                return n; 
            }
            m = st.top();
            st.pop();
        }
        else if (n == 0) {
            m = m - 1;
            n = 1;
        }
        else {
            st.push(m - 1); 
            n = n - 1;      
        }
    }
}
int main() {
	int m, n;
	cin >> m>>n;
	cout << ack(m, n) << endl;
	cout << nack(m, n) << endl;
}
```

## 效能分析

1. 時間複雜度：遞迴和非遞迴的時間複雜度為 $O(ack(m,n))$。
2. 空間複雜度：遞迴和非遞迴的空間複雜度為 $O(ack(m,n))$。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $n$ | 遞迴預期輸出 | 遞迴實際輸出 |非遞迴預期輸出 | 非遞迴實際輸出 |
|----------|--------------|----------|----------|----------|----------|
| 測試一   | $m = 1,n = 0$      | 2        | 2        |2        | 2        |
| 測試二   | $m = 1,n = 2$      | 4        | 4        | 4        | 4        |
| 測試三   | $m = 2,n = 2$      | 7        | 7        |7        | 7        |
| 測試四   | $m = 3,n = 8$      | 2045       | 2045       |2045       | 2045       |
| 測試五   | $m = 4,n = 1$     | 65533 | 卡死 | 65533 | 卡死 |
<img width="158" height="385" alt="螢幕擷取畫面 2025-10-11 212257" src="https://github.com/user-attachments/assets/b301d8e5-6b63-4a9c-9372-961f4fa710a1" />


### 結論
1. 由於 Ackermann 函數成長速度極快，當輸入值過大如 $m \ge 4$ 時，遞迴深度增加，容易導致堆疊溢位。
2. 經測試，程式可正確輸出 $m \le 3$ 且 $n \le 8$ 的結果，對於 $m=4$、$n>0$ 或更大輸入，因遞迴層數過深而無法計算。
## 申論及開發報告
本次實作的內容為 Ackermann 函數，為一個高度遞迴的數學函數，被用來測試程式語言遞迴呼叫的效能與堆疊深度限制。
在程式開發過程中，主要挑戰在於如何正確實作函數遞迴關係式。由於此函數的增長速度極為快速，當 $m$ 與 $n$ 稍大時，就會造成非常深的遞迴呼叫層級。
實測結果顯示，在一般環境下，程式可正確執行 $m \le 3$ 的各種輸入組合；但當 $m = 4$ 且 $n > 0$ 時，便可能因遞迴層數過深而發生堆疊溢位。


