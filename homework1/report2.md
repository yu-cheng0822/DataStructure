# 41343109

作業二

## 解題說明

本題要求設定S並輸出S的Powerset

### 解題策略

1. 使用verctor 存S的集合。
2. 然後用pow(2,n)計算出S powerset的數量
3.  用num去判斷子集合
## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
#include <vector>
#include<string>
#include<cmath>
using namespace std;

int main() {
	int n,count;
	string x;
	vector<string> S;
	while (cin >> x) {
		S.push_back(x);
	}
	n = S.size();
	count = pow(2, n);
	for (int i = 0; i < count; i++) {
		int num = i;
		cout << "{";
		for (int j = 0; j < n; j++) {
			if (num % 2 == 1)cout << S[j]; 
			num = num / 2;
		}
		cout << "}";
	}

}
```

## 效能分析

1. 時間複雜度：遞迴和非遞迴的時間複雜度為 $O(n*(2^n))$。
2. 空間複雜度：遞迴和非遞迴的空間複雜度為 $O(n)$。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $n$ | 遞迴預期輸出 | 遞迴實際輸出 |非遞迴預期輸出 | 非遞迴實際輸出 |
|----------|--------------|----------|----------|----------|----------|
| 測試一   | $m = 1,n = 0$      | 2        | 2        |2        | 2        |
| 測試二   | $m = 1,n = 2$      | 4        | 4        | 4        | 4        |
| 測試三   | $m = 2,n = 2$      | 7        | 7        |7        | 7        |
| 測試四   | $m = 3,n = 8$      | 2045       | 2045       |2045       | 2045       |
| 測試五   | $m = 4,n = 1$     | 65533 | 卡死 | 65533 | 卡死 |


### 結論
1. 由於 Ackermann 函數成長速度極快，當輸入值過大如 $m \ge 4$ 時，遞迴深度增加，容易導致堆疊溢位。
2. 經測試，程式可正確輸出 $m \le 3$ 且 $n \le 8$ 的結果，對於 $m=4$、$n>0$ 或更大輸入，因遞迴層數過深而無法計算。
## 申論及開發報告
本次實作的內容為 Ackermann 函數，為一個高度遞迴的數學函數，被用來測試程式語言遞迴呼叫的效能與堆疊深度限制。
在程式開發過程中，主要挑戰在於如何正確實作函數遞迴關係式。由於此函數的增長速度極為快速，當 $m$ 與 $n$ 稍大時，就會造成非常深的遞迴呼叫層級。
實測結果顯示，在一般環境下，程式可正確執行 $m \le 3$ 的各種輸入組合；但當 $m = 4$ 且 $n > 0$ 時，便可能因遞迴層數過深而發生堆疊溢位。
